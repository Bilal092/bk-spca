diff --git a/init/main.c b/init/main.c
index 66418ab..3cae0f5 100644
--- a/init/main.c
+++ b/init/main.c
@@ -471,10 +471,6 @@ asmlinkage void __init start_kernel(void)
 	extern const struct kernel_param __start___param[], __stop___param[];
 
 	printk(KERN_ALERT "penguins at last???\n");
-	printk(KERN_ALERT "penguins at last???\n");
-	printk(KERN_ALERT "penguins at last???\n");
-	printk(KERN_ALERT "penguins at last???\n");
-	printk(KERN_ALERT "penguins at last???\n");
 
 	/*
 	 * Need to run as early as possible, to initialize the
diff --git a/kernel/futex.c b/kernel/futex.c
index 8879430..de0255a 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -1006,6 +1006,13 @@ futex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)
 			/* Check if one of the bits is set in both bitsets */
 			if (!(this->bitset & bitset))
 				continue;
+			
+			if((400<=dv_print_flag)&&(dv_print_flag<500))
+				printk(KERN_ALERT 
+				       "calling wake_futex(this), " 
+				       "pid = %d, "
+				       "smp = %d\n",
+				       current->pid, smp_processor_id());
 
 			wake_futex(this);
 			if (++ret >= nr_wake)
@@ -1919,6 +1926,14 @@ retry:
 	if (ret)
 		goto out;
 
+
+	if((400<=dv_print_flag)&&(dv_print_flag<500))
+		printk(KERN_ALERT 
+		       "calling futex_wait_queue_me(), " 
+		       "pid = %d, "
+		       "smp = %d\n",
+		       current->pid, smp_processor_id());
+
 	/* queue_me and wait for wakeup, timeout, or a signal. */
 	futex_wait_queue_me(hb, &q, to);
 
@@ -2703,6 +2718,13 @@ SYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val,
 	u32 val2 = 0;
 	int cmd = op & FUTEX_CMD_MASK;
 
+	if((400<=dv_print_flag)&&(dv_print_flag<500))
+		printk(KERN_ALERT 
+		       "in syscall_futex(), " 
+		       "pid = %d, "
+		       "smp = %d\n",
+		       current->pid, smp_processor_id());
+
 	if (utime && (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||
 		      cmd == FUTEX_WAIT_BITSET ||
 		      cmd == FUTEX_WAIT_REQUEUE_PI)) {
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 26058d0..f8b1270 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -1957,6 +1957,15 @@ context_switch(struct rq *rq, struct task_struct *prev,
 
 	context_tracking_task_switch(prev, next);
 	/* Here we just switch the register state and the stack. */
+
+	
+	if((400<=dv_print_flag)&&(dv_print_flag<500))
+		printk(KERN_ALERT 
+		       "in context_switch(), calling switch_to(), "
+		       "pid = %d, "
+		       "smp = %d\n",
+		       current->pid, smp_processor_id());
+	
 	switch_to(prev, next, prev);
 
 	barrier();
@@ -2887,6 +2896,13 @@ static void __sched __schedule(void)
 	struct rq *rq;
 	int cpu;
 
+	if((400<=dv_print_flag)&&(dv_print_flag<500))
+		printk(KERN_ALERT 
+		       "in _schedule(), "
+		       "pid = %d, "
+		       "smp = %d\n\n", 
+		       current->pid, smp_processor_id());
+
 need_resched:
 	preempt_disable();
 	cpu = smp_processor_id();
